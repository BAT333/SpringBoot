OQ VAMOS APRENDER
Boas práticas na API
Tratamento de erros
Autenticação/Autorização
Tokens JWT
----------------------------------------------------------------------------------------------------------------------
RETORNO PADRONIZADO
RETORNO PARA EXCLUIR TEM RETORNA MAIS COMUM É 204
DELETA
return ResponseEntity.noContent().build(); -> esse retorna o 204
LISTAR
ResponseEntity.ok(object)-> esse devolve codigo 200 e algo no corpo da requisção
ATUALIZAR
ResponseEntity.ok(object)-> esse devolve codigo 200 e algo no corpo da requisção
DEVOLVER DADOS ATUALIZADO
CADASTRA
RETORNO PARA CADASTRA TEM RETORNA MAIS COMUM É 201
corpo dos dados ja cadastrados
e um protocolo http (Location)
return ResponseEntity.created(uri).body(dto);
created(uri)-> uri representa endereço
created(uri)-> spring vai cria cabeçario altomaticamente base na uro
body(dto)-> oq vc vai devolver -> no corpo da requição

CRIANDO CABEÇALHO E OQ VAI DEVOLVER NO CORPO DA REQUISÃO
PARA NÃO PEGAR A URL MANUALMENTE TIPO VC ESCREVE LOCALHOST8080, NOS USAMOS ISSO NO PARAMETRO -> UriComponentsBuilder builder,
PORQUE ELE JA PEGA CORPO URI, AUTOMATICAMENTE
URI uri = builder -> AQUI JA TA URI SALVA
URI uri = builder.path("/cliente/cadastra/{id}")-> AQUI ACRECENTA MAIS COISAS NA URI PEGA A URI ATUAL E ACRESCENTA MAIS OQ VC QUISER
QUE POR EXEMPLO COMPLEMENTO, QUE VAI SER USADO PARA CRIAR CABECARIO
URI uri = builder.path("/cliente/cadastra/{id}").buildAndExpand(clients.getId())-> AQUI VAI PEGAR ID DO MEDICO JA CADSTRADO NO BANCO E ADD
E TROCA {ID} PELO ID DO MEDICO MEIO QUE PARAMETRO DINAMICO
toUri()-> AQUI PARA TRASFORMAR EM OBJETO URI


UriComponentsBuilder builder
URI uri = builder.path("/cliente/cadastra/{id}").buildAndExpand(clients.getId()).toUri();
return ResponseEntity.created(uri).body(Client);

------------------------------------------------------------------------------------------------------------------------------------------------------------
ERROS QUE PODE OCORRE NA URI

Os códigos HTTP (ou HTTPS) possuem três dígitos, sendo que o primeiro dígito significa a classificação dentro das possíveis cinco categorias.

1XX: Informativo – a solicitação foi aceita ou o processo continua em andamento;

2XX: Confirmação – a ação foi concluída ou entendida;

3XX: Redirecionamento – indica que algo mais precisa ser feito ou precisou ser feito para completar a solicitação;

4XX: Erro do cliente – indica que a solicitação não pode ser concluída ou contém a sintaxe incorreta;

5XX: Erro no servidor – o servidor falhou ao concluir a solicitação.


O código 403 é o erro “Proibido”.-> CLIENTE NÃO TEM ACESSO ESSA INFOS

Error 404, significa que essa URL não te levou a lugar nenhum -> URL NÃO EXISTE

Error 500, basicamente, no servidor que mantém a aplicação no ar ou na comunicação com o sistema de arquivos, que fornece a infraestrutura para a aplicação.

Erro 503 significa que o serviço acessado está temporariamente indisponível

https://http.dog/
https://http.cat/


Nessa aula, você aprendeu como:
Utilizar a classe ResponseEntity, do Spring, para personalizar os retornos dos métodos de uma classe Controller;
Modificar o código HTTP devolvido nas respostas da API;
Adicionar cabeçalhos nas respostas da API;
Utilizar os códigos HTTP mais apropriados para cada operação realizada na API.
------------------------------------------------------------------------------------------------------------------------------


RETORNADO ERROS

Common Application Properties
server.error.include-stacktrace=never
esse tira a trace, oq seria diminuido retorno de infos que usario pode ver com erro
https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html



@RestControllerAdvice

essa notação indica que tratamneto de erro da spring
essa class para trata erro
@RestControllerAdvice
public class TratamentoDeErro {
}


 @ExceptionHandler(EntityNotFoundException.class)
    public ResponseEntity tratandoErro404(){
        return ResponseEntity.notFound().build();
    }

 @ExceptionHandler(EntityNotFoundException.class)
esse codigo diz basicamente, se Aparecer erro   EntityNotFoundException-> vai retornar tal coisa
return ResponseEntity.notFound().build();-> que é erro 404



//código omitido

@ExceptionHandler(MethodArgumentNotValidException.class)
public ResponseEntity tratarErro400(MethodArgumentNotValidException ex){
    var erros = ex.getFieldErrors();

    return ResponseEntity.badRequest().body(erros.stream().map(DadosErroValidacao::new).toList());

}

private record DadosErroValidacao(String campo, String mensagem) {
         public DadosErroValidacao(FieldError erro) {
                   this(erro.getField(),erro.getDefaultMessage());

         }
}


--------------------------------------------------------------------------------------------------------------------------------------------------------------------
public ResponseEntity tratarErro400(MethodArgumentNotValidException ex)-> se pega erro com parametro
var erros = ex.getFieldErrors();-> salva esse erros
return ResponseEntity.badRequest().body(erros.stream().map(DadosErroValidacao::new).toList());-> retorna esse erros
para pegar erro especificos vc faz um dto
badRequest->O código de status de resposta HTTP 400 Bad Request indica que o servidor não pode ou não irá processar a requisição devido a alguma coisa que foi entendida como um erro do cliente

Nessa aula, você aprendeu como:
Criar uma classe para isolar o tratamento de exceptions da API, com a utilização da anotação @RestControllerAdvice;
Utilizar a anotação @ExceptionHandler, do Spring, para indicar qual exception um determinado método da classe de tratamento de erros deve capturar;
Tratar erros do tipo 404 (Not Found) na classe de tratamento de erros;
Tratar erros do tipo 400 (Bad Request), para erros de validação do Bean Validation, na classe de tratamento de erros;
Simplificar o JSON devolvido pela API em casos de erro de validação do Bean Validation.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
spring sucuryti





















Você deve ter notado que o Bean Validation possui uma mensagem de erro para cada uma de suas anotações. Por exemplo, quando a validação falha em algum atributo anotado com @NotBlank, a mensagem de erro será: must not be blank.

Essas mensagens de erro não foram definidas na aplicação, pois são mensagens de erro padrão do próprio Bean Validation. Entretanto, caso você queira, pode personalizar tais mensagens.

Uma das maneiras de personalizar as mensagens de erro é adicionar o atributo message nas próprias anotações de validação:

public record DadosCadastroMedico(
    @NotBlank(message = "Nome é obrigatório")
    String nome,

    @NotBlank(message = "Email é obrigatório")
    @Email(message = "Formato do email é inválido")
    String email,

    @NotBlank(message = "Telefone é obrigatório")
    String telefone,

    @NotBlank(message = "CRM é obrigatório")
    @Pattern(regexp = "\\d{4,6}", message = "Formato do CRM é inválido")
    String crm,

    @NotNull(message = "Especialidade é obrigatória")
    Especialidade especialidade,

    @NotNull(message = "Dados do endereço são obrigatórios")
    @Valid DadosEndereco endereco) {}COPIAR CÓDIGO
Outra maneira é isolar as mensagens em um arquivo de propriedades, que deve possuir o nome ValidationMessages.properties e ser criado no diretório src/main/resources:

nome.obrigatorio=Nome é obrigatório
email.obrigatorio=Email é obrigatório
email.invalido=Formato do email é inválido
telefone.obrigatorio=Telefone é obrigatório
crm.obrigatorio=CRM é obrigatório
crm.invalido=Formato do CRM é inválido
especialidade.obrigatoria=Especialidade é obrigatória
endereco.obrigatorio=Dados do endereço são obrigatóriosCOPIAR CÓDIGO
E, nas anotações, indicar a chave das propriedades pelo próprio atributo message, delimitando com os caracteres { e }:

public record DadosCadastroMedico(
    @NotBlank(message = "{nome.obrigatorio}")
    String nome,

    @NotBlank(message = "{email.obrigatorio}")
    @Email(message = "{email.invalido}")
    String email,

    @NotBlank(message = "{telefone.obrigatorio}")
    String telefone,

    @NotBlank(message = "{crm.obrigatorio}")
    @Pattern(regexp = "\\d{4,6}", message = "{crm.invalido}")
    String crm,

    @NotNull(message = "{especialidade.obrigatoria}")
    Especialidade especialidade,

    @NotNull(message = "{endereco.obrigatorio}")
    @Valid DadosEndereco endereco) {}
